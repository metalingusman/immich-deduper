#!/usr/bin/env python3

import os
import sys
import re
import shutil
import subprocess
import tempfile
from pathlib import Path
from datetime import datetime

IMAGE_NAME = "razgrizhsu/immich-deduper"
BUILDER_NAME = "budx"

def err(msg):
	print(f"Error: {msg}", file=sys.stderr)
	sys.exit(1)

def run(cmd, quiet=True):
	result = subprocess.run(
		cmd,
		shell=isinstance(cmd, str),
		capture_output=quiet,
		text=True
	)
	if result.returncode != 0:
		if quiet and result.stderr: print(result.stderr, file=sys.stderr)
		return None
	return result.stdout.strip() if quiet else ""

def showHelp():
	print("""Usage: ./bu [options]

Options:
  -h, --help    Show this help
  -up           Push images to Docker Hub
  -gpu          Build only CUDA version (can combine with -up)
  -pub          Publish release to GitHub
  -tag TAG      Use custom tag instead of version from pyproject.toml

Examples:
  ./bu              Build locally
  ./bu -up          Build and push to Docker Hub
  ./bu -up -gpu     Build and push CUDA only
  ./bu -pub         Publish GitHub release (no build)
  ./bu -up -pub     Build, push, and publish
""")
	sys.exit(0)

def readVer(scriptDir):
	toml = scriptDir / "pyproject.toml"
	if not toml.exists(): err(f"pyproject.toml not found in {scriptDir}")

	for line in toml.read_text().splitlines():
		m = re.match(r'^version = "(.+)"', line)
		if m: return m.group(1)

	print("Warning: Could not read version from pyproject.toml, using 'latest'")
	return "latest"

def updateConfVer(scriptDir, ver):
	confPy = scriptDir / "src" / "conf.py"
	if not confPy.exists():
		print("Warning: src/conf.py not found, skipping version update")
		return

	orig = confPy.read_text()
	updated = re.sub(r"version\s*=\s*'[^']*'", f"version = '{ver}'", orig)
	if orig == updated:
		print(f"Version in src/conf.py already {ver}, skipping...")
		return
	print(f"Updating version in src/conf.py to {ver}...")
	confPy.write_text(updated)

	result = subprocess.run(
		["python3", "-c", f"""
import sys, os
sys.path.insert(0, './src')
try:
    from conf import envs
    print('  conf.py syntax check passed')
    print(f'  Version read from conf.py: {{envs.version}}')
    if envs.version != '{ver}':
        print('  Version mismatch in conf.py')
        sys.exit(1)
    print('  Version update successful')
except Exception as e:
    print(f'  Error checking conf.py: {{str(e)}}')
    sys.exit(1)
"""],
		cwd=str(scriptDir),
		text=True
	)

	if result.returncode != 0:
		confPy.write_text(orig)
		err("Python syntax check or version read failed, restored backup")

def ensureBuilder():
	check = subprocess.run(
		["docker", "buildx", "inspect", BUILDER_NAME],
		capture_output=True
	)
	if check.returncode != 0:
		print(f"Docker Buildx builder '{BUILDER_NAME}' not found. Creating it...")
		run(f"docker buildx create --name {BUILDER_NAME} --driver docker-container --use")
	else:
		print(f"Using Docker Buildx builder '{BUILDER_NAME}'.")
		run(f"docker buildx use {BUILDER_NAME}")

def buildImg(tag, device, tagSuffix, platforms, push=False):
	fullTag = f"{IMAGE_NAME}:{tag}{tagSuffix}"
	print(f"Building {device} image: {fullTag}")

	buildArgs = [
		"--build-arg", "DEDUP_PORT=8086",
		"--build-arg", f"DEVICE={device}",
		"."
	]

	cmd = [
		"docker", "buildx", "build",
		"--platform", platforms,
		"-t", fullTag,
	]

	if push:
		latestTag = f"{IMAGE_NAME}:latest{tagSuffix}"
		cmd += ["-t", latestTag]
		if device == "cpu":
			cmd += ["-t", f"{IMAGE_NAME}:latest-cpu"]
		cmd += ["--push"]
	else: cmd += ["--load"]

	cmd += buildArgs

	result = subprocess.run(cmd)
	if result.returncode != 0: err(f"Build failed for {fullTag}")

def buildAll(tag, upload, gpuOnly):
	ensureBuilder()

	if upload:
		print("Building multi-platform Docker images and pushing to Docker Hub")
		if gpuOnly:
			print("Building CUDA version only")
			buildImg(tag, "cuda", "-cuda", "linux/amd64", push=True)
		else:
			plat = "linux/amd64,linux/arm64/v8"
			buildImg(tag, "cpu", "", plat, push=True)
			buildImg(tag, "cuda", "-cuda", "linux/amd64", push=True)
			print("Successfully built and pushed both CPU and CUDA versions.")
	else:
		print("Building Docker images for current host platform (not pushing).")
		arch = run("uname -m") or "amd64"
		curPlat = f"linux/{arch.replace('aarch64', 'arm64').replace('x86_64', 'amd64')}"

		if gpuOnly:
			print("Building CUDA version only")
			buildImg(tag, "cuda", "-cuda", "linux/amd64")
		else:
			buildImg(tag, "cpu", "", curPlat)
			print("Building CUDA version for AMD64 platform")
			buildImg(tag, "cuda", "-cuda", "linux/amd64")
			print("Successfully built and loaded images for local testing.")

def publish(tag, scriptDir):
	print("Publishing release to GitHub...")
	run("git fetch --prune --prune-tags")
	gitTag = f"v{tag}"
	title = gitTag

	prevTag = run(f"git tag --sort=-v:refname | grep -v 'v{tag}' | head -1")
	rng = f"{prevTag}..HEAD" if prevTag else "HEAD~10..HEAD"

	rawCommits = run(f"git log --oneline --no-merges {rng}")
	merges = run(f"git log --oneline --merges {rng}")
	kept = ("break", "fix", "feat", "mod", "upd", "refactor", "db", "log", "performance", "beta", "ui")
	print(f"  Range: {rng}")
	if not rawCommits:
		print("  No commits found")
		changelog = "- No new commits"
	else:
		msg = lambda l: l.split(" ", 1)[-1]
		allLines = rawCommits.splitlines()
		breaking = [l for l in allLines if msg(l).startswith("break")]
		others = [l for l in allLines if any(msg(l).startswith(p) for p in kept[1:])]
		skipped = [l for l in allLines if l not in breaking and l not in others]
		print(f"  Found {len(allLines)} commits:")
		for l in breaking + others:
			print(f"    ✓ {l}")
		for l in skipped:
			print(f"    ✗ {l}")
		parts = []
		if breaking:
			parts.append("**Breaking Changes**")
			parts += [f"- {l}" for l in breaking]
			if others: parts.append("")
		parts += [f"- {l}" for l in others]
		if merges:
			contribs = []
			for line in merges.splitlines():
				m = re.search(r'Merge pull request #(\d+) from ([^/]+)/', line)
				if m:
					prNum, author = m.groups()
					prTitle = run(f"gh pr view {prNum} --json title --jq .title") or ""
					contribs.append((prNum, author, prTitle))
			if contribs:
				parts.append("")
				parts.append("## Contributors")
				for prNum, author, prTitle in contribs:
					parts.append(f"- @{author}: {prTitle} (#{prNum})")
		changelog = "\n".join(parts) if parts else "- No notable changes"

	notes = f"""Release {tag}

## Changes
{changelog}"""

	# prepare assets first, before any irreversible operations
	assetDir = Path(tempfile.mkdtemp())
	dockerDir = scriptDir / "docker"

	prefixMap = {
		"same-host": "(same-host)",
		"different-host": "(diff-host)",
	}

	for hostDir, prefix in prefixMap.items():
		srcDir = dockerDir / hostDir
		if not srcDir.exists(): continue
		for f in srcDir.iterdir(): shutil.copy2(f, assetDir / f"{prefix} {f.name}")

	assets = [str(f) for f in assetDir.iterdir()]
	if not assets:
		shutil.rmtree(assetDir)
		err("No assets found in docker/ directories")

	print("\n" + "="*50)
	print(f"Release Preview: {gitTag}")
	print("="*50)
	print(notes)
	print("\n" + "-"*50)
	print("Assets:")
	for a in assets:
		print(f"  - {Path(a).name}")
	print("-"*50)

	confirm = input("\nProceed with release? [y/N]: ").strip().lower()
	if confirm != 'y':
		shutil.rmtree(assetDir)
		print("Release cancelled.")
		sys.exit(0)

	# delete existing tag/release
	check = subprocess.run(["git", "rev-parse", gitTag], capture_output=True, text=True)
	if check.returncode == 0:
		print(f"Tag {gitTag} exists, deleting old version...")
		subprocess.run(["git", "tag", "-d", gitTag], capture_output=True)
		print("  Deleted local tag")
		subprocess.run(["git", "push", "origin", "--delete", gitTag], capture_output=True)
		print("  Deleted remote tag")
		subprocess.run(["gh", "release", "delete", gitTag, "--yes"], capture_output=True)
		print("  Deleted GitHub release")

	run(f"git tag -a {gitTag} -m 'Release {tag}'")
	print(f"  Tag {gitTag} created")

	run(f"git push origin {gitTag}")
	print(f"  Tag pushed")

	result = subprocess.run(
		["gh", "release", "create", gitTag, "--title", title, "--notes", notes] + assets
	)

	shutil.rmtree(assetDir)

	if result.returncode != 0: err("Publish failed")

	print(f"Published {gitTag} to GitHub")

def main():
	args = sys.argv[1:]

	if "-h" in args or "--help" in args: showHelp()

	upload = False
	gpuOnly = False
	pubRelease = False
	customTag = ""

	i = 0
	while i < len(args):
		arg = args[i]
		if arg == "-up": upload = True
		elif arg == "-gpu": gpuOnly = True
		elif arg == "-pub": pubRelease = True
		elif arg == "-tag":
			if i + 1 >= len(args): err("-tag requires a value")
			customTag = args[i + 1]
			i += 1
		else: err(f"Unknown option: {arg}\nRun with -h for help")
		i += 1

	scriptDir = Path(__file__).resolve().parent
	os.chdir(scriptDir)

	ver = readVer(scriptDir)
	updateConfVer(scriptDir, ver)
	tag = customTag or ver

	if pubRelease:
		if not shutil.which("gh"): err("gh not found, please install GitHub CLI")
		if run("gh auth status") is None: err("Not logged in to GitHub, run 'gh auth login'")

	# -pub without -up: skip build
	if not (pubRelease and not upload):
		print("Starting Docker image build process...")

		reqFiles = ["requirements.txt", "requirements-cuda.txt", "Dockerfile"]
		for f in reqFiles:
			if not (scriptDir / f).exists(): err(f"{f} not found")
		if not (scriptDir / "src").is_dir(): err("src directory not found")

		buildAll(tag, upload, gpuOnly)

	if pubRelease: publish(tag, scriptDir)

	print("Build process completed.")

if __name__ == "__main__":
	try: main()
	except KeyboardInterrupt:
		print("\nInterrupted")
		sys.exit(1)
